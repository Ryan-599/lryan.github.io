---
layout: default
title:  "论文-A Thousand Ways to Pack the Bin"
date:   2023-06-24 23:38:00 +0800
categories: paper
---
<head>
<script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
</head>

<script> 
MathJax = {
  tex: {
    inlineMath: [['$', '$']],
    processEscapes: true
  }
};
</script>

# 目录

1. 二维装箱问题简介
2. 经典算法
   - Shelf算法
   - Guillotine算法
   - 最大矩形算法
   - Skyline算法
3. 其他问题

# 正文

1. 二维装箱问题简介  
   二维装箱问题是一个经典的组合优化问题。该问题需要求解将一个矩形序列$(R_1,R_2,...,R_n)$中的每个$R_i$尽可能地、互不重叠地放入一个长宽固定的二维矩形箱中。该问题被证明是一个NP-hard问题。
2. 经典算法
   - **Shelf算法**

      Shelf算法是一种简单的装箱方法。首先将整个二维矩形箱从下到上分割成一层一层的货架（Shelf），在每一层上从左到右地放置矩形。由于是从下到上进行分割，所以最顶层往往是未使用的，可以对最顶层进行再次分割。而除了最顶层外，其他层的高度是固定的，这些层是封闭的，不能再进行改变。

      在对一个矩形进行装箱时，Shelf算法将这个矩形放到哪一层，哪一层的哪个位置上依据于其自身的启发性函数。常见的Shelf启发性函数有：
      - Next Fit：对一个矩形进行装箱时，尝试将该矩形放入当前货架上，如果不能放入，则向上开辟新一层的货架。如果不能开辟新的货架，那么算法终止。
      - First Fit：对一个矩形进行装箱时，从下到上扫描一遍所有货架，选择第一个能装入该矩形的货架将其放入。
      - Best Width Fit：对一个矩形进行装箱时，从下到上扫描一遍所有货架，选择能装入该矩形的货架中，剩余可用宽度最小的那一个。
      - Best Height Fit：对一个矩形进行装箱时，从下到上扫描一遍所有货架，选择能装入该矩形的货架中，高度最小的那一个。
      - Best Area Fit：对一个矩形进行装箱时，从下到上扫描一遍所有货架，选择能装入该矩形的货架中，可用面积最小的那一个。
      - Worst Width Fit

      Waste-Map改善：使用Shelf算法进行装箱时，每一个货架上半部分的空间往往是空闲的。使用Guillotine算法记录并追踪每一层的空闲空间，对一个矩形进行装箱时，优先使用Guillotine算法将该矩形装入这些空闲空间中。如果不能装入空闲空间，则照常使用Shelf算法。

   - **Guillotine算法**  

      Guillotine算法是一种剪切的方法。它的基本原理是将一个空闲的矩形逐步分解成多个空闲的小矩形。分解的方法是先将空闲的矩形直接截去一个角，然后沿着截去的角的边，以垂直或水平的方法将剩余空间截成两个较小的空闲矩形。如下图所示：

      ![picture 1](\images\d940acc30d06878a7cfece2248d7be4be01aa0b169597b10b0653d7c5601c7d1.png)  

      Guillotine算法维护一个空闲矩形列表${F_1,...,F_n}$，该列表实际上就是对箱中剩余空间的一个划分。初始时，该列表只有一个空闲矩形块，即箱本身。在对一个矩形进行装箱时，从列表中选取一个能装入该矩形的空闲矩形$F_i$并将该矩形放在$F_i$的左下角，进行上述的剪切操作，得到两个新的空闲矩形$F_i'$和$F_i^{''}$并加入到列表中。

      Guillotine算法缺陷在于，它必须要选择一个完全能容纳目标矩形的空闲矩形才能完成装箱操作。而事实上，一些空闲矩形可以合并成一个更大的空间，可以容纳一些单个空闲矩形不能容纳的目标矩形。

      为了完成Guillotine算法，还需要制定一些启发式规则。如选择哪一个$F_i$？，选择$F_i$并且放置目标矩形后选择水平还是垂直切割？一般来说，有如下几种启发式规则：
      - Best Area Fit：选择能装入目标矩形的那些空闲矩形中，面积最小的那一个
      - Best Short Side Fit：对目标矩形$R=(w,h)$，选择$F_i=(w_f, h_f)$使得$min(w_f-w, h_f-h)$最小，即最小化截取目标矩形后剩余的较短的那条边长。
      - Best Long Side Fit：对目标矩形$R=(w,h)$，选择$F_i=(w_f, h_f)$使得$max(w_f-w, h_f-h)$最小，即最小化截取目标矩形后剩余的较长的那条边长。
      - Worst Fit Rules

      矩形合并改善：Guillotine算法的最大问题是矩形不能自由放置在自由区域的任意位置，必须沿着分割线进行放置。这导致即使有充足的空间的也不能放置目标矩形。使用矩形合并的方法来解决这个问题，检测所有空闲矩形，查看是否有一对矩形$F_i,F_j$能够被合并为一个更大的矩形$F_k$，如果能合并则删除它们之间的分割线。

      Guillotine算法的分割规则：
      - 短轴/长轴拆分规则：在短轴拆分规则下，对$F_i=(w_f, h_f)$，若$w_f<h_f$则按水平分割，反之按垂直分割；在长轴拆分规则下，刚好相反。
      - 较短/较长的剩余轴长分割：在较短剩余轴长分割的规则下，对$F_i=(w_f, h_f)$，若$w_f-w<h_f-h$则按水平分割，反之按垂直分割；在较长剩余轴长分割的规则下，刚好相反。
      - 最大/最小面积分割规则：水平和垂直各分割一次，得到$A_1~A_4$四个区域，其中$A_4$是目标矩形，$A_3$是公共区域，$A_1$和$A_2$是水平切割和垂直切割的剩余区域。对最小面积分割规则，选择将$A_3$与$A_1$和$A_2$之间的较大者合并；对最大面积分割规则，选择将$A_3$与$A_1$和$A_2$之间的较小者合并。

   - **最大矩形算法**

      最大矩形算法某种程度上是Guillotine算法的拓展。类似于Guillotine算法，最大矩形算法也存储一个代表箱中剩余空间的空闲矩形列表，但与Guillotine算法选择垂直分割还是水平分割不同，最大矩形算法执行的操作很大程度上综合考虑了这两种操作。如下图所示：

      ![picture 2](\images\1482620a1b9ccfa343b2a594e494c67232b902d3e87d074951f4242677ba8d12.png)  

      如上图所示，当需要放置一块目标矩形时，需要更新的空闲矩形是最右的两块矩形。这两块矩形包含了相同的公共部分。这样做的好处是明显的，随机在空闲矩形列表中取一个能够装入目标矩形的$F_i$，$F_i$不会出现即使有足够空间但因为分割线而无法进行分配的情况。这样做的坏处是，空闲矩形列表中的每个空闲矩形不再是互相独立的，某两个空闲矩形间总会有交集。于是在选择好$F_i$后，还要遍历一次空闲矩形列表，判断裁剪掉的形状中是否包含了公共部分。若$F_j$包含了公共部分，则需要将$F_i$减去被裁掉的形状，并拆成最多四个新的小矩形。

      做完上述步骤后，还需要进一步对空闲列表做简化工作。简化工作主要是考察任意$F_i$和$F_j$，是否存在$F_j \in F_i$的情况，若有，则删除$F_j$。出现这种情况的原因可能是拆成小矩形的原矩形不止一个，而这些小矩形可能互相包含。

      ![picture 3](\images\3a6038f625dd3b9d027fc5f01ba7ee11df7a1e92aacbd709c435acb8de506471.png)  

      当有多个$F_i$符合要求时，选择哪一个$F_i$进行装箱呢？有以下几种常见的选择规则。
      - Bottom-Left：遍历空闲矩形列表，选择能装入目标矩形的空闲矩形$F_i$，其中$F_i$的纵坐标一定是最小的，如果有多个空闲矩形纵坐标相同，那么选择横坐标最小的。
      - Best Area Fit：遍历空闲矩形列表，选择能装入目标矩形的空闲矩形$F_i$，其中$F_i$的面积一定是最小的。
      - Best Short Side Fit：对目标矩形$R=(w,h)$，选择$F_i=(w_f, h_f)$使得$min(w_f-w, h_f-h)$最小，即最小化截取目标矩形后剩余的较短的那条边长。
      - Best Long Side Fit：对目标矩形$R=(w,h)$，选择$F_i=(w_f, h_f)$使得$max(w_f-w, h_f-h)$最小，即最小化截取目标矩形后剩余的较长的那条边长。
      - Contact Point：对目标矩形$R=(w,h)$，选择$F_i$使得$R$与$F_i$之间的边缘重合度最大，亦即重合边缘周长最长。

   - **Skyline算法**

      和最大矩形算法相比，Skyline算法更加简化，运行速度也更好。类似于Shelf算法，Skyline算法对空闲空间是“有损”的，也就是说，它并不能完美地追踪所有空闲空间，甚至会将一些未用空间标记为已用空间。Skyline数据结构只维护那些已装入箱中的矩形的上边界，也被称为天际线（skyline）。在装入一个目标矩形时，根据当前的skyline列表决定将目标矩形放在哪个位置。具体的位置由一些启发式函数决定。

      ![picture 4](images/0220c05c1c02cae393cb7302cd73381992cdac6e5884c84a84254fb8d14d7a7b.png)  


      - Bottom-Left：将目标矩形放置在使得目标矩形的顶边最低的位置，在都是最低的情况，将其左对齐。这种方法很像从下往上搭积木。
      - Best Fit：对目标矩形要放置的侯选位置，计算可能会浪费的空间，选择将其放置在浪费空间最小的位置。如果出现相等的情况，那么使用Bottom-Left方法。

      Waste-Map改善：与Shelf算法相同，使用Guillotine算法管理可能出现的浪费空间。

3. 一般性的算法改善方法